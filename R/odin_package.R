##' Create an odin model within an existing package.
##'
##' I am resisting the urge to actually create the package here.
##' There are better options than I can come up with; for example
##' \code{devtools::create}, \code{pkgkitten::kitten},
##' \code{mason::mason}, or creating \code{DESCRIPTION} files using
##' \code{desc}.  What is required here is that your package:
##'
##' \itemize{
##' \item{Lists \code{odin} in \code{Imports:}}
##' \item{Includes \code{useDynLib{<your package name>}} in
##'   \code{NAMESPACE} (possibly via a roxygen comment \code{@useDynLib
##'   <your package name>}}
##' \item{To avoid a NOTE in \code{R CMD check}, import something from
##'   \code{odin} in your namespace (e.g., \code{importFrom("odin", "odin")}
##'   or roxygen \code{@importFrom(odin, odin)}}
##' }
##'
##' Point this function at the package root (the directory containing
##' \code{DESCRIPTION} and it will write out files \code{src/odin.c}
##' and \code{odin.R}.  These files will be overwritten without
##' warning by running this again.
##'
##' There are a few unresolved issues with this approach, notably
##' activating "native symbol registration", and the interaction with
##' packages such as Rcpp that automatically collate a list of
##' symbols.  The mechanism may change in a future version, though the
##' interface (with source files in \code{inst/odin} will remain the
##' same.
##'
##' @title Create odin model in a package
##' @param path_package Path to the package root (the directory that
##'   contains \code{DESCRIPTION})
##'
##' @export
##' @examples
##' path <- tempfile()
##' dir.create(path)
##'
##' src <- system.file("examples/package", package = "odin", mustWork = TRUE)
##' file.copy(src, path, recursive = TRUE)
##' pkg <- file.path(path, "package")
##'
##' # The package is minimal:
##' dir(pkg)
##'
##' # But contains odin files in inst/odin
##' dir(file.path(pkg, "inst/odin"))
##'
##' # Compile the odin code in the package
##' odin::odin_package(pkg)
##'
##' # Which creates the rest of the package structure
##' dir(pkg)
##' dir(file.path(pkg, "R"))
##' dir(file.path(pkg, "src"))
odin_package <- function(path_package) {
  desc <- file.path(path_package, "DESCRIPTION")
  if (!file.exists(desc)) {
    stop("Did not find package at ", path_package)
  }
  package <- as.vector(read.dcf(desc, "Package"))
  if (is.na(package)) {
    stop("Failed to get package name from DESCRIPTION")
  }

  inst_odin <- file.path(path_package, "inst/odin")
  if (!is_directory(inst_odin)) {
    stop("Did not find inst/odin within your package")
  }
  filenames <- dir(inst_odin, pattern = "\\.[Rr]", full.names = TRUE)

  if (length(filenames) == 0L) {
    stop("Did not find any files in inst/odin")
  }

  options <- odin_options(target = "c")
  f <- function(path) {
    ir <- odin_parse_(path, options)
    dat <- ir_deserialise(ir)
    json <- sub("\\.[Rr]$", ".json", path)
    writeLines(ir, json)
    dat$ir <- sprintf("odin/%s", basename(json))
    generate_c_code(dat, options, package)
  }

  dat <- lapply(filenames, f)

  ring <- drop_null(lapply(dat, "[[", "ring"))
  if (length(ring) > 0L) {
    ring <- ring[[1L]]
  }

  interpolate <- drop_null(lapply(dat, "[[", "interpolate"))
  if (length(interpolate) > 0L) {
    interpolate <- interpolate[[1L]]
  }

  include <- drop_null(lapply(dat, "[[", "include"))
  if (length(include) > 0L) {
    include <- combine_include(include)
  }

  lib_used <- unique(unlist(lapply(dat, function(x) x$lib$used)))
  lib <- dat[[1]]$lib$lib

  header <- "Automatically generated by odin - do not edit"

  code_c <- c(
    paste("//", header),
    dat[[1]]$headers,
    c_flatten_eqs(ring$declarations),
    c_flatten_eqs(interpolate$declarations),
    c_flatten_eqs(lapply(dat, "[[", "struct")),
    c_flatten_eqs(lapply(dat, function(x) x$core$declaration)),
    unname(lib$declarations[lib_used]),
    c_flatten_eqs(include$declarations),
    c_flatten_eqs(lapply(dat, function(x) x$core$definition)),
    c_flatten_eqs(strsplit(lib$definitions[lib_used], "\n")),
    c_flatten_eqs(ring$definitions),
    c_flatten_eqs(interpolate$definitions),
    c_flatten_eqs(include$definitions))
  code_r <- c(paste("##", header), c_flatten_eqs(lapply(dat, "[[", "r")))

  dir.create(file.path(path_package, "R"), FALSE)
  dir.create(file.path(path_package, "src"), FALSE)
  writeLines(code_c, file.path(path_package, "src", "odin.c"))
  writeLines(code_r, file.path(path_package, "R", "odin.R"))
}
